options
{
  STATIC = false;
  JAVA_UNICODE_ESCAPE = false; // Should not pre parse the unicode escape
  UNICODE_INPUT = true; // Should accept unicode character from the Reader
  JDK_VERSION = "1.8";
}

PARSER_BEGIN(JavaCallParser)
package io.ebean.migration.custom.parse;
import java.util.*;
import java.time.*;

/**
 * RunStaticMethodCommandParser. Autogenerated
 */
@SuppressWarnings({"unchecked", "rawtypes", "unused", "serial"})
public class JavaCallParser {

  /**
   * Parses the given string.
   */
  public JavaCallParser(String in) {
    this (new java.io.StringReader(in));
  }
}
PARSER_END(JavaCallParser)

/**
 * Handle unnecessary characters and comments 
 */
SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" }

/**
 * These are all the available tokens in a command.
 */
TOKEN :
{
  // misc tokens
  < O_PAREN : "(" >
| < C_PAREN : ")" >
| < O_ARRAY : "[" >
| < C_ARRAY : "]" >
| < O_OBJECT : "{" >
| < C_OBJECT : "}" >
| < COMMA : "," >
| < COLON : ":" >
  // possible argument types
| < NULL : "null" >
| < NumDouble : ([ "+", "-" ])? (< Digit >)* "." (< Digit >)+ (< Exponent >)? >
| < NumInteger : ([ "+", "-" ])? (< Digit >)+ (< Exponent >)? >
| < STRING :
    "\"" // Start at "
    (
      ~[ "\"" ] // until " 
    | "\\\"" // but not \" (escaped)
    )*
    "\"" > // end at "

| < Identifier :  (< Letter >)  (< Letter > | < Digit > | "." )* >
  // DatePattern is YYYY-MM-DD
| < IsoDate : (< Digit > < Digit > < Digit > < Digit > "-" < Digit > < Digit > "-" < Digit > < Digit >) >
  // Timepattern is hh:mm:ss or hh:mm:ss.msec
| < IsoTime : ( < Digit > < Digit > ":" < Digit > < Digit > ":" < Digit > < Digit > ("." (< Digit >)+ )? ) >
  // DateTimePattern is <IsoDate>T<IsoTime>, <IsoDate>T<IsoTime>Z, <IsoDate>T<IsoTime>+01:00
| < IsoDateTime :
    (
      < IsoDate > "T" < IsoTime >
      (
        "Z"
      | ([ "+", "-" ] < Digit > < Digit > ":" < Digit > < Digit >)
      )?
    ) >
| < #Exponent : [ "e", "E" ] ([ "+", "-" ])? (< Digit >)+ >
  // Common groups
| < #Letter : 
    [ 
    "$", // $
    "A"-"Z", // A-Z
    "_", // _
    "a"-"z", // a-z
    "~", // ~
    "\u00c0"-"\u00d6", // À - Ö
    "\u00d8"-"\u00f6", // Ø - ö
    "\u00f8"-"\u00ff", // ø - ÿ
    "\u0100"-"\u1fff", // Latin Extended - A
    "\u3040"-"\u318f", // HIRAGANA/KATAKANA LETTER
    "\u3300"-"\u337f", // CJK Compatibility
    "\u3400"-"\u3d2d", // CJK Unified ideographs Extension A
    "\u4e00"-"\u9fff", // CJK Unified ideographs Extension A
    "\uf900"-"\ufaff" // CJK ... other
    ]
  >
|
  < #Digit : [ "0"-"9" ] >
}

/**
 * main production: <code>io.ebean.myCommand(1,2,3)</code>
 */
public JavaCall parse() :
{
  Token t;
  List<Object> args = Collections.emptyList();
}
{
  t = < Identifier >
  ( args = arguments() )?
  { return new JavaCall(t.image, args); }
    
}

/**
 * Arguments could be:
 * <ul>
 * <li><code>()</code> no argument</li>
 * <li><code>(1)</code> int argument</li>
 * <li><code>(1, "hello")</code> int argument</li>
 * <li><code>(1, 2017-01-01T01:01:01)</code> iso date time argument</li>
 * </ul>
 */
private List < Object > arguments() :
{
  List < Object > args = new ArrayList < Object > ();
  Object v; // stores the value.
}
{
  < O_PAREN >
  (
    v = value()
    { args.add(v); }
    (
      < COMMA > v = value()
      { args.add(v); }
    )*
  )?
  < C_PAREN >
  { return args; }
}

/**
 * Handle scalar values like string, int, and date times or array/map
 */
private Object value() :
{
  Token t;
  Object v;
}
{
  < NULL >
  { return null; }
| 
  v = array()
  { return v; }
| 
  v = object()
  { return v; }
| 
  t = < STRING >
  { return ParseUtil.deQuoteString(t.image); }
| 
  t = < NumDouble >
  { return Double.valueOf(t.image); }
| 
  t = < NumInteger >
  { return Integer.valueOf(t.image); }
| 
  t = < IsoDate >
  { return LocalDate.parse(t.image); }
| 
  t = < IsoTime >
  { return LocalTime.parse(t.image); }
| 
  t = < IsoDateTime >
  { return OffsetDateTime.parse(t.image); }
}

/**
 * Handles arrays, e.g <code>[1,2,null]</code>
 */
private List < Object > array() :
{
  List < Object > elems = new ArrayList < Object > ();
  Object v;
}
{
  < O_ARRAY >
  (
    v = value()
    { elems.add(v); }
    (
      < COMMA > v = value()
      { elems.add(v); }
    )*
  )?
  < C_ARRAY >
  { return elems; }
}

/**
 * Handles objects, e.g <code> {"key1":"value1", "key2":"value2"]</code>
 */
private Map < Object, Object > object() :
{
  Map < Object, Object > elems = new HashMap < Object, Object > ();
  Object key;
  Object v;
}
{
  < O_OBJECT >
  (
    key = value() < COLON > v = value()
    { elems.put(key, v);}
    (
      < COMMA > key = value() < COLON > v = value()
      { elems.put(key, v); }
    )*
  )?
  < C_OBJECT >
  { return elems; }
}
